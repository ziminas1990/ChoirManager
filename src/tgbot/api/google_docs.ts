import fs from "fs";
import { google, Auth, sheets_v4, docs_v1 } from "googleapis";


import { Status, StatusWith } from "../../status.js";


export class GoogleDocsAPI {

    private static auth: Auth.GoogleAuth | undefined = undefined;

    private static sheets?: sheets_v4.Sheets;
    private static documents?: docs_v1.Docs;

    public static authenticate(google_cloud_key_file: string): Status {

        let credentials: any | undefined = undefined;
        try {
            credentials = JSON.parse(fs.readFileSync(google_cloud_key_file, "utf8"));
        } catch (error) {
            return Status.fail(`Failed to load credentials: ${error}`);
        }
        if (!credentials) {
            return Status.fail("Failed to load credentials. File is empty?");
        }

        GoogleDocsAPI.auth = new google.auth.GoogleAuth({
            credentials: credentials,
            scopes: [
                "https://www.googleapis.com/auth/spreadsheets.readonly",
                "https://www.googleapis.com/auth/documents.readonly"
            ],
        });
        return Status.ok();
    }

    public static get_sheets(): sheets_v4.Sheets {
        if (!GoogleDocsAPI.sheets) {
            GoogleDocsAPI.sheets = google.sheets({ version: "v4", auth: GoogleDocsAPI.get_auth() });
        }
        return GoogleDocsAPI.sheets;
    }

    public static get_documents(): docs_v1.Docs {
        if (!GoogleDocsAPI.documents) {
            GoogleDocsAPI.documents = google.docs({ version: "v1", auth: GoogleDocsAPI.get_auth() });
        }
        return GoogleDocsAPI.documents;
    }

    private static get_auth(): Auth.GoogleAuth {
        if (!GoogleDocsAPI.auth) {
            throw new Error("Google Docs API is not initialized");
        }
        return GoogleDocsAPI.auth;
    }
}

export type Row = string[];
export type Table = Row[];


export class GoogleSpreadsheet {

    constructor(private sheet_id: string) {}

    public async read(range: string): Promise<StatusWith<Table>> {
        try {
            const sheet = await GoogleDocsAPI.get_sheets().spreadsheets.values.get({
                spreadsheetId: this.sheet_id,
                range: range
            });
            if (!sheet.data.values) {
                return Status.fail("can't fetch sheet data");
            }
            return Status.ok().with(sheet.data.values);
        } catch (err) {
            return Status.exception(err).wrap("Failed to read sheet");
        }
    }
}

// type MarkdownElement = {
//     what: "text",
//     text: string,
// } | {
//     what: "link",
//     text: string,
//     url: string,
// } | {
//     what: "list",
//     items: MarkdownElement[],
// } | {
//     what: "header",
//     level: number,
//     text: string,
// }

export class GoogleDocument {

    constructor(private document_id: string) {}

    public async read(): Promise<StatusWith<string>> {
        const res = await GoogleDocsAPI.get_documents().documents.get({
            documentId: this.document_id
        });
        const content = res.data.body?.content || [];
        const text = content.map((el) => {
            return el.paragraph?.elements?.map((e) => {
                return e.textRun?.content || ""
            }).join("") || ""
        }).join("\n");

        return Status.ok().with(text.trim());
    }

    // Return document as a simple markdown. Only lists, headers and links are supported,
    // tables, images and other complex elements are ignored.
    // Each element in the returned array is a section of the document and starts with a
    // level 1 header. If document has no headers, all content will be in a single section.
    // TODO: this code was completely generated by co-pilot (claude 3.7) and needs to be
    // rewritten to be more readable and maintainable.
    public async read_as_simple_markdown(): Promise<StatusWith<string[]>> {
        try {
            const res = await GoogleDocsAPI.get_documents().documents.get({
                documentId: this.document_id
            });
            const content = res.data.body?.content || [];

            const sections: string[] = [];
            let currentSection = "";
            let inList = false;
            let listLevel = 0;

            for (const element of content) {
                // Skip elements without paragraphs
                if (!element.paragraph) {
                    continue;
                }

                const paragraph = element.paragraph;
                const style = paragraph.paragraphStyle;

                // Check if this is a header
                if (style?.namedStyleType?.includes('HEADING')) {
                    const headerLevel = parseInt(style.namedStyleType.replace('HEADING_', ''));

                    // If it's a level 1 header, start a new section
                    if (headerLevel === 1) {
                        if (currentSection) {
                            sections.push(currentSection.trim());
                        }
                        currentSection = "";
                    }

                    // Add the header with appropriate markdown formatting
                    currentSection += '#'.repeat(headerLevel) + ' ';
                    currentSection += this.extractTextFromParagraph(paragraph) + '\n\n';
                    inList = false;
                    continue;
                }

                // Handle lists
                if (paragraph.bullet) {
                    const newListLevel = paragraph.bullet.nestingLevel || 0;

                    // If list level changed, add appropriate spacing
                    if (!inList || newListLevel !== listLevel) {
                        if (!inList) currentSection += '\n';
                        inList = true;
                        listLevel = newListLevel;
                    }

                    // Add indentation based on nesting level
                    currentSection += '  '.repeat(listLevel) + '* ';
                    currentSection += this.extractTextFromParagraph(paragraph) + '\n';
                    continue;
                }

                // Regular paragraph
                if (inList) {
                    currentSection += '\n';
                    inList = false;
                }

                currentSection += this.extractTextFromParagraph(paragraph) + '\n\n';
            }

            // Add the last section if not empty
            if (currentSection) {
                sections.push(currentSection.trim());
            }

            // If no sections were created (no level 1 headers), put all content in one section
            if (sections.length === 0 && currentSection) {
                sections.push(currentSection.trim());
            }

            return StatusWith.ok().with(sections);
        } catch (error) {
            return StatusWith.fail(`Failed to read document: ${error}`);
        }
    }

    // Helper method to extract text with formatting from paragraph elements
    private extractTextFromParagraph(paragraph: any): string {
        let text = '';

        if (!paragraph.elements) return text;

        for (const element of paragraph.elements) {
            if (!element.textRun?.content) continue;

            let content = element.textRun.content;
            const textStyle = element.textRun.textStyle || {};

            // Handle links
            if (textStyle.link?.url) {
                text += `[${content.trim()}](${textStyle.link.url})`;
            }
            // Handle basic formatting
            else {
                if (textStyle.bold) content = `**${content.trim()}**`;
                if (textStyle.italic) content = `*${content.trim()}*`;
                text += content;
            }
        }

        return text.replace(/\n/g, ' ').trim();
    }
}